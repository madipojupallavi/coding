import os
import logging
import streamlit as st
import bnym_eliza as eliza
from bnym_eliza.utils import init_logger, get_jwt_from_certs
import json
import fitz  # PyMuPDF for PDF text extraction and writing
import tempfile
from typing import Dict, List, Any
import pandas as pd

# Initialize logger
log = init_logger(__name__)

# Constants
BASE_FOLDER = r'C:\Users\A\Downloads'  # For cert/key files
CERT_PATH = os.path.join(BASE_FOLDER, 'public 9.cer')
PRIVATE_KEY_PATH = os.path.join(BASE_FOLDER, 'private 9.key')

# Folder containing sample docs
DOCS_FOLDER = r'C:\Users\A\Sync_Data\DocumentSamples'

# Folder containing JSON schemas
SCHEMA_FOLDER = os.path.join(os.path.dirname(__file__), 'schema')

# Output folder for generated PDFs
OUTPUT_FOLDER = r'C:\Users\A\Sync_Data\OutputPDFs'

# Ensure output folder exists
os.makedirs(OUTPUT_FOLDER, exist_ok=True)

def query_eliza_chat(session, model: str, prompt: str) -> str:
    """
    Query Eliza ChatCompletion with given session, model, and prompt.
    Returns the content string from the response.
    """
    try:
        response = eliza.ChatCompletion.create(
            model=model,
            messages=[{"role": "user", "content": prompt}]
        )
        content = response["choices"][0]["message"]["content"]
        return content
    except Exception as e:
        log.error(f"Error during eliza chat completion: {e}")
        raise

def get_jwt():
    """
    Generate JWT token using certificate and private key paths.
    Raises an exception if generation fails.
    """
    try:
        token = get_jwt_from_certs(CERT_PATH, PRIVATE_KEY_PATH)
        log.info("JWT token successfully generated.")
        return token
    except Exception as e:
        log.error(f"Failed to generate JWT token: {e}")
        raise

def load_schema(form_name: str) -> Dict[str, Any]:
    """
    Load JSON schema for a given form name.
    """
    try:
        schema_path = os.path.join(SCHEMA_FOLDER, f"{form_name}.json")
        with open(schema_path, 'r', encoding='utf-8') as f:
            return json.load(f)
    except Exception as e:
        log.error(f"Error loading schema for {form_name}: {e}")
        raise

def extract_pdf_fields(pdf_path: str) -> List[Dict[str, str]]:
    """
    Extract form fields from PDF using PyMuPDF.
    Returns list of field information.
    """
    try:
        doc = fitz.open(pdf_path)
        fields = []
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            widgets = page.widgets()
            
            for widget in widgets:
                field_info = {
                    'field_name': widget.field_name,
                    'field_type': str(widget.field_type),
                    'field_value': widget.field_value,
                    'page_num': page_num,
                    'rect': widget.rect
                }
                fields.append(field_info)
        
        doc.close()
        return fields
    
    except Exception as e:
        log.error(f"Error extracting PDF fields from {pdf_path}: {e}")
        raise

def generate_synthetic_data(jwt_token: str, model: str, schema: Dict[str, Any]) -> Dict[str, Any]:
    """
    Generate synthetic data based on schema using LLM.
    """
    try:
        mandatory_fields = schema.get('mandatory_fields', {})
        
        # Create prompt for LLM
        prompt = f"""
        Generate synthetic data for a PDF form with the following mandatory fields:
        {json.dumps(mandatory_fields, indent=2)}
        
        Please return a JSON object with field names as keys and appropriate synthetic values.
        Ensure all values are realistic and properly formatted for the field types.
        For dates, use YYYY-MM-DD format.
        For boolean fields, use true/false.
        For text fields, generate realistic sample data.
        
        Return only the JSON object, no additional text.
        """
        
        response = query_eliza_chat(jwt_token, model, prompt)
        
        # Try to parse JSON response
        try:
            return json.loads(response)
        except json.JSONDecodeError:
            # If response is not valid JSON, try to extract JSON from response
            import re
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                return json.loads(json_match.group())
            else:
                raise ValueError("Could not extract valid JSON from LLM response")
                
    except Exception as e:
        log.error(f"Error generating synthetic data: {e}")
        raise

def fill_pdf_form(pdf_path: str, data: Dict[str, Any], output_path: str) -> bool:
    """
    Fill PDF form fields with generated data and save to output path.
    """
    try:
        doc = fitz.open(pdf_path)
        fields_filled = 0
        
        for page_num in range(len(doc)):
            page = doc.load_page(page_num)
            widgets = page.widgets()
            
            for widget in widgets:
                field_name = widget.field_name
                
                if field_name in data:
                    try:
                        value = data[field_name]
                        
                        # Handle different field types
                        if widget.field_type == fitz.PDF_WIDGET_TYPE_CHECKBOX:
                            if isinstance(value, bool):
                                widget.field_value = value
                            elif isinstance(value, str):
                                widget.field_value = value.lower() in ['true', '1', 'yes', 'on']
                        
                        elif widget.field_type == fitz.PDF_WIDGET_TYPE_RADIOBUTTON:
                            widget.field_value = str(value)
                        
                        else:  # Text fields and others
                            widget.field_value = str(value)
                        
                        widget.update()
                        fields_filled += 1
                        
                    except Exception as field_error:
                        log.warning(f"Error filling field {field_name}: {field_error}")
        
        # Save the filled PDF
        doc.save(output_path)
        doc.close()
        
        log.info(f"Successfully filled {fields_filled} fields in PDF: {output_path}")
        return True
        
    except Exception as e:
        log.error(f"Error filling PDF form: {e}")
        return False

def create_preview_data(data: Dict[str, Any]) -> pd.DataFrame:
    """
    Create a DataFrame for preview display.
    """
    preview_data = []
    for field_name, value in data.items():
        preview_data.append({
            'Field Name': field_name,
            'Generated Value': str(value),
            'Data Type': type(value).__name__
        })
    
    return pd.DataFrame(preview_data)

def main():
    """
    Main Streamlit application.
    """
    st.set_page_config(
        page_title="PDF Sync Data Generator",
        page_icon="üìÑ",
        layout="wide"
    )
    
    st.title("üìÑ PDF Sync Data Generator")
    st.markdown("Generate synthetic data for PDF forms using AI and fill them automatically")
    
    # Sidebar for configuration
    st.sidebar.header("Configuration")
    
    # Form selection
    form_options = ["w8", "w9", "onboarding", "ccmddq", "cbddq", "onboardingcorporate"]
    selected_forms = st.sidebar.multiselect(
        "Select PDF Forms to Generate",
        form_options,
        help="Choose one or more PDF forms to generate data for"
    )
    
    # LLM model selection
    llm_models = [
        "gpt-4", 
        "gpt-3.5-turbo", 
        "eliza-advanced", 
        "eliza-base"
    ]
    selected_model = st.sidebar.selectbox(
        "Select LLM Model",
        llm_models,
        help="Choose the AI model for data generation"
    )
    
    # Number of responses
    num_responses = st.sidebar.slider(
        "Number of Responses per Form",
        min_value=1,
        max_value=20,
        value=3,
        help="How many filled PDFs to generate for each form"
    )
    
    if not selected_forms:
        st.info("üëÜ Please select at least one PDF form from the sidebar to get started.")
        return
    
    # Main content area
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.subheader(f"Selected Forms: {', '.join(selected_forms)}")
        st.write(f"**Model:** {selected_model}")
        st.write(f"**Responses per form:** {num_responses}")
        
        # Preview and Generate buttons
        preview_btn = st.button("üîç Preview Generated Data", type="secondary")
        generate_btn = st.button("üöÄ Generate and Fill PDFs", type="primary")
        
    with col2:
        st.subheader("Process Status")
        status_placeholder = st.empty()
        progress_placeholder = st.empty()
    
    # Preview functionality
    if preview_btn:
        try:
            status_placeholder.info("üîÑ Generating preview data...")
            jwt_token = get_jwt()
            
            preview_data = {}
            
            for form_name in selected_forms:
                with st.expander(f"üìã Preview for {form_name.upper()}", expanded=True):
                    try:
                        # Load schema
                        schema = load_schema(form_name)
                        
                        # Generate one sample
                        sample_data = generate_synthetic_data(jwt_token, selected_model, schema)
                        preview_data[form_name] = sample_data
                        
                        # Create preview DataFrame
                        df = create_preview_data(sample_data)
                        st.dataframe(df, use_container_width=True)
                        
                        # Show schema info
                        st.write(f"**Mandatory fields:** {len(schema.get('mandatory_fields', {}))}")
                        
                    except Exception as e:
                        st.error(f"Error generating preview for {form_name}: {str(e)}")
            
            status_placeholder.success("‚úÖ Preview generated successfully!")
            
        except Exception as e:
            status_placeholder.error(f"‚ùå Error generating preview: {str(e)}")
    
    # Generate and fill functionality
    if generate_btn:
        try:
            status_placeholder.info("üîÑ Initializing generation process...")
            jwt_token = get_jwt()
            
            total_operations = len(selected_forms) * num_responses
            current_operation = 0
            
            progress_bar = progress_placeholder.progress(0)
            
            generated_files = []
            
            for form_name in selected_forms:
                st.write(f"### Processing {form_name.upper()}")
                
                try:
                    # Load schema
                    schema = load_schema(form_name)
                    pdf_path = os.path.join(DOCS_FOLDER, f"{form_name}.pdf")
                    
                    if not os.path.exists(pdf_path):
                        st.error(f"PDF template not found: {pdf_path}")
                        continue
                    
                    # Generate multiple responses
                    for i in range(num_responses):
                        current_operation += 1
                        progress = current_operation / total_operations
                        progress_bar.progress(progress)
                        
                        status_placeholder.info(f"üîÑ Generating {form_name} #{i+1}...")
                        
                        # Generate synthetic data
                        synthetic_data = generate_synthetic_data(jwt_token, selected_model, schema)
                        
                        # Create output filename
                        output_filename = f"{form_name}_filled_{i+1}.pdf"
                        output_path = os.path.join(OUTPUT_FOLDER, output_filename)
                        
                        # Fill PDF form
                        if fill_pdf_form(pdf_path, synthetic_data, output_path):
                            generated_files.append({
                                'form': form_name,
                                'file': output_filename,
                                'path': output_path
                            })
                            st.success(f"‚úÖ Generated: {output_filename}")
                        else:
                            st.error(f"‚ùå Failed to generate: {output_filename}")
                
                except Exception as e:
                    st.error(f"Error processing {form_name}: {str(e)}")
            
            # Summary
            status_placeholder.success(f"‚úÖ Generation complete! Created {len(generated_files)} files.")
            progress_bar.progress(1.0)
            
            # Download section
            if generated_files:
                st.subheader("üì• Download Generated Files")
                
                for file_info in generated_files:
                    col_download, col_info = st.columns([1, 3])
                    
                    with col_download:
                        try:
                            with open(file_info['path'], 'rb') as file:
                                st.download_button(
                                    label=f"‚¨áÔ∏è {file_info['file']}",
                                    data=file.read(),
                                    file_name=file_info['file'],
                                    mime="application/pdf"
                                )
                        except Exception as e:
                            st.error(f"Error creating download button: {e}")
                    
                    with col_info:
                        st.write(f"**Form:** {file_info['form'].upper()}")
                        st.write(f"**Path:** `{file_info['path']}`")
        
        except Exception as e:
            status_placeholder.error(f"‚ùå Error during generation: {str(e)}")
            log.error(f"Generation error: {e}")

if __name__ == "__main__":
    main()


# Schema Files for PDF Forms

You'll need to create JSON schema files in the `schema/` folder for each form type. Here are example schema files:

## w8.json
```json
{
    "form_name": "W8",
    "form_type": "tax_form",
    "mandatory_fields": {
        "name": {
            "type": "text",
            "description": "Full legal name",
            "required": true
        },
        "country_of_citizenship": {
            "type": "text", 
            "description": "Country of tax residence",
            "required": true
        },
        "permanent_address": {
            "type": "text",
            "description": "Permanent address",
            "required": true
        },
        "us_tin": {
            "type": "text",
            "description": "U.S. taxpayer identification number",
            "required": false
        },
        "foreign_tin": {
            "type": "text", 
            "description": "Foreign tax identifying number",
            "required": true
        },
        "signature": {
            "type": "text",
            "description": "Digital signature",
            "required": true
        },
        "date_signed": {
            "type": "date",
            "description": "Date of signature",
            "required": true
        }
    }
}
```

## w9.json
```json
{
    "form_name": "W9", 
    "form_type": "tax_form",
    "mandatory_fields": {
        "name": {
            "type": "text",
            "description": "Name as shown on your income tax return",
            "required": true
        },
        "business_name": {
            "type": "text",
            "description": "Business name/disregarded entity name",
            "required": false
        },
        "tax_classification": {
            "type": "select",
            "description": "Federal tax classification",
            "options": ["Individual", "Corporation", "Partnership", "LLC"],
            "required": true
        },
        "address": {
            "type": "text", 
            "description": "Address (number, street, apt/suite no.)",
            "required": true
        },
        "city_state_zip": {
            "type": "text",
            "description": "City, state, and ZIP code", 
            "required": true
        },
        "ssn_ein": {
            "type": "text",
            "description": "Social Security Number or Employer Identification Number",
            "required": true
        },
        "signature": {
            "type": "text",
            "description": "Signature",
            "required": true
        },
        "date": {
            "type": "date",
            "description": "Date",
            "required": true
        }
    }
}
```

## onboarding.json
```json
{
    "form_name": "Client Onboarding",
    "form_type": "client_form", 
    "mandatory_fields": {
        "client_name": {
            "type": "text",
            "description": "Full client name",
            "required": true
        },
        "company_name": {
            "type": "text",
            "description": "Company/Organization name", 
            "required": true
        },
        "email": {
            "type": "email",
            "description": "Primary email address",
            "required": true
        },
        "phone": {
            "type": "text",
            "description": "Phone number",
            "required": true
        },
        "business_type": {
            "type": "select",
            "description": "Type of business",
            "options": ["Corporation", "LLC", "Partnership", "Sole Proprietorship", "Non-Profit"],
            "required": true
        },
        "account_type": {
            "type": "select", 
            "description": "Account type requested",
            "options": ["Basic", "Premium", "Enterprise"],
            "required": true
        },
        "compliance_officer": {
            "type": "text",
            "description": "Assigned compliance officer",
            "required": false
        }
    }
}
```

## ccmddq.json (Customer Due Diligence)
```json
{
    "form_name": "CCMDDQ",
    "form_type": "due_diligence",
    "mandatory_fields": {
        "entity_name": {
            "type": "text", 
            "description": "Legal entity name",
            "required": true
        },
        "jurisdiction": {
            "type": "text",
            "description": "Jurisdiction of incorporation",
            "required": true
        },
        "entity_type": {
            "type": "select",
            "description": "Entity type",
            "options": ["Corporation", "Limited Partnership", "Fund", "Trust"],
            "required": true
        },
        "regulatory_status": {
            "type": "text",
            "description": "Regulatory status/classification",
            "required": true
        },
        "aum": {
            "type": "number",
            "description": "Assets under management (USD millions)",
            "required": true
        },
        "primary_contact": {
            "type": "text",
            "description": "Primary contact person",
            "required": true
        },
        "contact_email": {
            "type": "email", 
            "description": "Contact email",
            "required": true
        }
    }
}
```

## cbddq.json (Counterparty Due Diligence)
```json
{
    "form_name": "CBDDQ",
    "form_type": "due_diligence",
    "mandatory_fields": {
        "counterparty_name": {
            "type": "text",
            "description": "Legal name of counterparty",
            "required": true
        },
        "lei_code": {
            "type": "text",
            "description": "Legal Entity Identifier",
            "required": true
        },
        "credit_rating": {
            "type": "select", 
            "description": "Credit rating",
            "options": ["AAA", "AA", "A", "BBB", "BB", "B", "CCC", "Unrated"],
            "required": true
        },
        "country_risk": {
            "type": "text",
            "description": "Country of primary operations",
            "required": true
        },
        "business_relationship": {
            "type": "text",
            "description": "Nature of business relationship",
            "required": true
        },
        "transaction_volume": {
            "type": "number", 
            "description": "Expected annual transaction volume (USD millions)",
            "required": true
        },
        "risk_assessment": {
            "type": "select",
            "description": "Overall risk assessment",
            "options": ["Low", "Medium", "High"],
            "required": true
        }
    }
}
```

## onboardingcorporate.json
```json
{
    "form_name": "Corporate Onboarding",
    "form_type": "corporate_client",
    "mandatory_fields": {
        "corporate_name": {
            "type": "text",
            "description": "Legal corporate name",
            "required": true
        },
        "incorporation_date": {
            "type": "date",
            "description": "Date of incorporation",
            "required": true
        },
        "registered_address": {
            "type": "text",
            "description": "Registered business address", 
            "required": true
        },
        "business_purpose": {
            "type": "text",
            "description": "Primary business purpose/activities",
            "required": true
        },
        "authorized_signatory": {
            "type": "text",
            "description": "Authorized signatory name",
            "required": true
        },
        "signatory_title": {
            "type": "text", 
            "description": "Title of authorized signatory",
            "required": true
        },
        "annual_revenue": {
            "type": "number",
            "description": "Annual revenue (USD millions)",
            "required": true
        },
        "employee_count": {
            "type": "number",
            "description": "Number of employees",
            "required": true
        },
        "banking_relationship": {
            "type": "select",
            "description": "Type of banking relationship desired",
            "options": ["Cash Management", "Credit Facilities", "Investment Services", "Comprehensive"],
            "required": true
        }
    }
}
```

## Directory Structure
```
your-project/
‚îú‚îÄ‚îÄ pdf-sync-data-generator.py
‚îú‚îÄ‚îÄ schema/
‚îÇ   ‚îú‚îÄ‚îÄ w8.json
‚îÇ   ‚îú‚îÄ‚îÄ w9.json  
‚îÇ   ‚îú‚îÄ‚îÄ onboarding.json
‚îÇ   ‚îú‚îÄ‚îÄ ccmddq.json
‚îÇ   ‚îú‚îÄ‚îÄ cbddq.json
‚îÇ   ‚îî‚îÄ‚îÄ onboardingcorporate.json
‚îú‚îÄ‚îÄ C:/Users/A/Sync_Data/
‚îÇ   ‚îú‚îÄ‚îÄ DocumentSamples/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ w8.pdf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ w9.pdf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ onboarding.pdf
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ccmddq.pdf  
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ cbddq.pdf
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ onboardingcorporate.pdf
‚îÇ   ‚îî‚îÄ‚îÄ OutputPDFs/
‚îÇ       ‚îî‚îÄ‚îÄ (generated files will be saved here)
```


You are an expert in Quality Assurance, tasked with generating detailed and exhaustive test
cases for the provided user story information exported from Jira. The input will be an Excel
sheet containing details of a single Jira story, including fields such as Summary,
Description, Acceptance Criteria, and any Dependencies.

Your objective is to ensure that the test cases are comprehensive, covering all relevant
functional scenarios, while being clear and concise. Ensure dependencies between user
stories are considered when applicable.

Input (from Jira export in Excel):  
{jira_excel_data}

Task:
Generate functional test cases that thoroughly cover the entire functionality described in
the Jira story. Ensure both positive and negative test cases are provided for a comprehensive
assessment of all possible scenarios. The generated test cases should align with the
acceptance criteria of the story and consider any dependencies.

Instructions for Test Case Generation:
1. Extract User Story Context:
   - Use the Summary and Description from the Excel sheet to understand the story.
   - Use Acceptance Criteria as the guiding rules for validation.
   - Consider Dependencies if they are listed.
2. Break Down Story:
   - Split the story into logical steps and generate test cases for each step, ensuring maximum coverage of all scenarios.
   - Include both positive and negative test cases to assess functionality, error handling, and edge cases.
3. Prerequisites Requirement:
   - For EACH test case, explicitly define the PREREQUISITES that must be met before executing the test.
   - Prerequisites should include:
     a) System configurations required
     b) Preconditions or states that must exist
     c) Data setup or user account preparations
     d) Any dependencies or prior actions needed
4. Ensure the Output Test Cases format is strictly valid JSON. Do not include comments, markdown, or any text outside the JSON structure and also don't include placeholders. Do not generate ambiguous test cases - all test steps, test data, and expected results must be specific and unambiguous. The structure must follow BDD (Given‚ÄìWhen‚ÄìThen) style for scenarios:

[
  {
    "testCaseId": "Unique Test Case ID",
    "userStory": "User story (derived from Summary/Description)",
    "testCase": "Short description of the test case",
    "prerequisites": "Detailed list of all prerequisites required to execute this test case in numbered bullets format",
    "bddScenario": {
        "given": [
            "List of preconditions or initial state"
        ],
        "when": [
            "List of actions or steps performed"
        ],
        "then": [
            "List of expected outcomes and validations"
        ]
    },
    "testSteps": [
      {
        "stepNumber": 1,
        "stepDescription": "Detailed description of the test step",
        "testData": "Specific test data to be used for this step (e.g., input values, file names, URLs, etc.)",
        "expectedResult": "Expected outcome or behavior for this specific step"
      },
      {
        "stepNumber": 2,
        "stepDescription": "Detailed description of the test step",
        "testData": "Specific test data to be used for this step",
        "expectedResult": "Expected outcome or behavior for this specific step"
      }
    ]
  },
  ...
]

5. It doesn't mean to generate only one positive and one negative test case, generate as many as possible for that user story but maintain the format.
6. Based on features and variables in the user story, generate separate test cases for every permutation.

Sample Positive Test Case (BDD JSON):

{
  "testCaseId": "TC_POS_01",
  "userStory": "As a user, I want to log in to the application so that I can access my account features.",
  "testCase": "Verify successful login for valid credentials.",
  "prerequisites": "1. User account exists in the system\\n2. Network connection is stable\\n3. Login page is accessible",
  "bddScenario": {
    "given": [
      "The user is on the login page",
      "A valid user account exists in the system"
    ],
    "when": [
      "The user enters a valid username",
      "The user enters a valid password",
      "The user clicks the 'Login' button"
    ],
    "then": [
      "The system accepts the username and password without validation errors",
      "The user is redirected to the homepage",
      "A welcome message is displayed"
    ]
  },
  "testSteps": [
    {
      "stepNumber": 1,
      "stepDescription": "Navigate to the login page",
      "testData": "URL: https://app.example.com/login",
      "expectedResult": "Login page loads successfully with username and password fields visible"
    },
    {
      "stepNumber": 2,
      "stepDescription": "Enter valid username in the username field",
      "testData": "Username: testuser@example.com",
      "expectedResult": "Username is entered without any validation errors"
    },
    {
      "stepNumber": 3,
      "stepDescription": "Enter valid password in the password field",
      "testData": "Password: ValidPass123!",
      "expectedResult": "Password is entered and masked with asterisks or dots"
    },
    {
      "stepNumber": 4,
      "stepDescription": "Click the Login button",
      "testData": "N/A",
      "expectedResult": "Login button is clickable and triggers authentication process"
    },
    {
      "stepNumber": 5,
      "stepDescription": "Verify successful login and redirection",
      "testData": "N/A",
      "expectedResult": "User is redirected to homepage with welcome message displaying username"
    }
  ]
}

Sample Negative Test Case (BDD JSON):

{
  "testCaseId": "TC_NEG_01",
  "userStory": "As a user, I want to log in to the application so that I can access my account features.",
  "testCase": "Verify error message when login fails due to invalid password.",
  "prerequisites": "1. User account exists in the system\\n2. Network connection is stable\\n3. Login page is accessible",
  "bddScenario": {
    "given": [
      "The user is on the login page",
      "A valid user account exists in the system"
    ],
    "when": [
      "The user enters a valid username",
      "The user enters an invalid password",
      "The user clicks the 'Login' button"
    ],
    "then": [
      "The system detects the invalid password",
      "An error message is displayed: 'Invalid username or password'"
    ]
  },
  "testSteps": [
    {
      "stepNumber": 1,
      "stepDescription": "Navigate to the login page",
      "testData": "URL: https://app.example.com/login",
      "expectedResult": "Login page loads successfully with username and password fields visible"
    },
    {
      "stepNumber": 2,
      "stepDescription": "Enter valid username in the username field",
      "testData": "Username: testuser@example.com",
      "expectedResult": "Username is entered without any validation errors"
    },
    {
      "stepNumber": 3,
      "stepDescription": "Enter invalid password in the password field",
      "testData": "Password: WrongPassword123",
      "expectedResult": "Invalid password is entered and masked with asterisks or dots"
    },
    {
      "stepNumber": 4,
      "stepDescription": "Click the Login button",
      "testData": "N/A",
      "expectedResult": "Login button is clickable and triggers authentication process"
    },
    {
      "stepNumber": 5,
      "stepDescription": "Verify error message display",
      "testData": "N/A",
      "expectedResult": "Error message 'Invalid username or password' is displayed in red text below login form"
    }
  ]
}

Additional Instructions:
1. For each test case:
   - Ensure the BDD Scenarios (Given, When, Then) are clearly broken down and exhaustive.
   - Include all possible validation, error-handling, and edge-case scenarios.
   - Ensure scenarios align with the acceptance criteria and interdependencies.
2. Provide test cases that include:
   - Validations for common functionalities like adding, editing, managing, and deleting data.
   - Multi-step processes, especially those requiring confirmations or transactions.
   - Error handling, validation messages, and workflows involving conflicting or missing data.
3. Ensure the test cases are exhaustive and detailed, covering maximum functional scenarios, but are presented in a clear and concise format.
4. We need test cases for every user story after breaking that into logical steps.
