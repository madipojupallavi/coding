def generate_report(self, test_duration, metrics):
    """Generate Excel report with full latency metrics and error breakdown"""
    df_results = pd.DataFrame(self.results)
    
    with pd.ExcelWriter(OUTPUT_EXCEL, engine='openpyxl') as writer:
        # --- Sheet 1: Detailed Results ---
        df_results.to_excel(
            writer,
            sheet_name='Detailed Results',
            index=False,
            columns=[
                "token_generation_time",
                "process_id",
                "api_status",
                "response_time_sec",
                "success",
                "error_type"  # New column for error classification
            ]
        )

        # --- Sheet 2: Summary (Full Metrics) ---
        summary_data = {
            'Metric': [
                'Total Processes',
                'Successful APIs',
                'HTTP Failures (4xx/5xx)',
                'Silent Failures (Crashes/Timeouts)',
                'Error Rate',
                'Average Response Time',
                'Min Response Time',
                'Max Response Time',
                'Median Response Time',
                '90th Percentile Response Time',
                '95th Percentile Response Time',
                'Std Dev Response Time',
                'Total Test Duration',
                'Throughput',
                'Token Refresh Count'
            ],
            'Value': [
                metrics["total_processes"],
                metrics["successful_apis"],
                metrics["http_failures"],
                metrics["silent_failures"],
                f"{metrics['error_rate']:.2f}%",
                f"{metrics['avg_latency']:.4f} sec",
                f"{metrics['min_latency']:.4f} sec",
                f"{metrics['max_latency']:.4f} sec",
                f"{metrics['median_latency']:.4f} sec",
                f"{metrics['p90_latency']:.4f} sec",
                f"{metrics['p95_latency']:.4f} sec",
                f"{metrics['std_dev_latency']:.4f} sec",
                f"{metrics['total_duration']:.2f} sec",
                f"{metrics['throughput']:.2f} req/sec",
                metrics["refresh_count"]
            ]
        }
        pd.DataFrame(summary_data).to_excel(
            writer,
            sheet_name='Summary',
            index=False
        )

        # --- Sheet 3: Error Breakdown ---
        error_types = {
            "Error Type": list(metrics["error_types"].keys()) + ["Total"],
            "Count": list(metrics["error_types"].values()) + [sum(metrics["error_types"].values())]
        }
        pd.DataFrame(error_types).to_excel(
            writer,
            sheet_name='Error Breakdown',
            index=False
        )

        # --- Sheet 4: Response Time Distribution ---
        dist_data = {
            'Response Time Bin': metrics['response_time_distribution']['labels'],
            'Request Count': metrics['response_time_distribution']['counts']
        }
        pd.DataFrame(dist_data).to_excel(
            writer,
            sheet_name='Response Time Distribution',
            index=False
        )

        # --- Formatting ---
        workbook = writer.book
        
        # Highlight failures in Detailed Results
        red_fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")
        sheet = workbook['Detailed Results']
        for row in sheet.iter_rows(min_row=2, max_col=6, max_row=len(df_results)+1):
            if not row[4].value:  # 'success' column
                for cell in row:
                    cell.fill = red_fill
        
        # Auto-adjust column widths
        for sheetname in writer.sheets:
            sheet = workbook[sheetname]
            for column in sheet.columns:
                max_length = max(len(str(cell.value)) for cell in column)
                adjusted_width = (max_length + 2) * 1.2  # Extra padding
                sheet.column_dimensions[column[0].column_letter].width = adjusted_width

        # Add bold headers
        for sheetname in writer.sheets:
            sheet = workbook[sheetname]
            for cell in sheet[1]:  # Header row
                cell.font = cell.font.copy(bold=True)
