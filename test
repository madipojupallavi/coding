import sys
import subprocess
import time
import statistics
import json
import requests
from concurrent.futures import ThreadPoolExecutor
from urllib.parse import parse_qs, urlencode

# ==============================================
# CONFIGURATION SECTION - UPDATE THESE VALUES
# ==============================================
URL_AUTH = "https://api.example.com/v1/resource"          # Authentication endpoint (POST)
URL_PROCESSING = "https://api.example2.com/v1/get-processUid"  # Process UID generation (GET)
URL_API = "https://api.example3.com/v1/profile/{processUid}"    # Status checking (GET)
USERNAME = "myusername"                                   # API username
PASSWORD = "mypassword"                                  # API password
QUERY_PARAMS = "key1=val1&key2=val2"                     # Query parameters for GET requests
POST_BODY = "key1=val1&key2=val2"                       # Request body for POST operations
PFX_PATH = "./client_cert.p12"                           # Path to client certificate
PFX_PASSPHRASE = "secret_passphrase"                     # Certificate passphrase
VERIFY_SSL = True                                        # Verify SSL certificates

# Performance Test Configuration
TEST_DURATION = 60               # Test duration in seconds
MAX_THREADS = 10                 # Maximum concurrent threads
POLL_INTERVAL = 2                # Interval between status checks (seconds)
MAX_RETRIES = 5                  # Maximum retries for failed requests
# ==============================================

class APITester:
    def __init__(self):
        self.requests_pkcs12 = self._ensure_requests_pkcs12()
        self.token = None
        self.auth_time = 0
        self.session = None
        self._parse_parameters()

    def _parse_parameters(self):
        """Parse the query parameters and body into different formats"""
        try:
            # Parse query parameters for GET requests
            self.query_params = parse_qs(QUERY_PARAMS)
            self.query_string = QUERY_PARAMS
            
            # Parse body for POST requests
            self.body_form = POST_BODY
            self.body_dict = parse_qs(POST_BODY)
            self.body_json = {k: v[0] if len(v) == 1 else v for k, v in self.body_dict.items()}
        except Exception as e:
            print(f"Error parsing parameters: {e}")
            self.query_params = {}
            self.query_string = ""
            self.body_form = POST_BODY
            self.body_dict = {}
            self.body_json = {}

    def _ensure_requests_pkcs12(self):
        """Ensure requests_pkcs12 is available"""
        try:
            import requests_pkcs12
            return requests_pkcs12
        except ImportError:
            print("Installing requests_pkcs12...")
            subprocess.check_call([sys.executable, "-m", "pip", "install", "requests_pkcs12"])
            import requests_pkcs12
            return requests_pkcs12

    def _create_session(self):
        """Create a reusable session with authentication"""
        self.session = requests.Session()
        if self.token:
            self.session.headers.update({
                "Authorization": f"Bearer {self.token}",
                "Accept": "application/json",
                "Content-Type": "application/x-www-form-urlencoded"
            })

    def _make_request(self, method, url, params=None, body=None, content_type=None, **kwargs):
        """Generic request handler with error handling"""
        # Default parameters
        request_params = {
            "verify": VERIFY_SSL,
            "timeout": 30,
            **kwargs
        }
        
        if PFX_PATH:
            request_params.update({
                "pkcs12_filename": PFX_PATH,
                "pkcs12_password": PFX_PASSPHRASE
            })
        
        # Handle query parameters for GET requests
        if params and method.upper() == "GET":
            if isinstance(params, str):
                url = f"{url}?{params}"
            elif isinstance(params, dict):
                url = f"{url}?{urlencode(params)}"
        
        # Handle body for POST requests
        headers = {}
        if content_type:
            headers["Content-Type"] = content_type
        
        if body:
            if isinstance(body, dict):
                request_params['json'] = body
            else:
                request_params['data'] = body
        
        if headers:
            request_params['headers'] = headers
        
        try:
            if method.upper() == "GET":
                response = self.requests_pkcs12.get(url, **request_params)
            elif method.upper() == "POST":
                response = self.requests_pkcs12.post(url, **request_params)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")
            
            response.raise_for_status()
            return response
        
        except requests.exceptions.RequestException as e:
            error_msg = f"Request failed: {method} {url}"
            if hasattr(e, 'response') and e.response:
                error_msg += f" | Status: {e.response.status_code}"
                try:
                    error_msg += f" | Response: {e.response.text[:200]}"
                except:
                    pass
            print(error_msg, file=sys.stderr)
            raise

    def authenticate(self):
        """Authenticate and get access token with multiple fallback methods"""
        start_time = time.time()
        
        auth_methods = [
            self._try_certificate_auth,
            self._try_basic_auth,
            self._try_token_auth,
            self._try_custom_auth
        ]
        
        for method in auth_methods:
            try:
                self.token = method(URL_AUTH)
                if self.token:
                    self.auth_time = time.time() - start_time
                    self._create_session()
                    print(f"Authentication successful using {method.__name__}")
                    return True
            except Exception as e:
                print(f"Auth method {method.__name__} failed: {e.__class__.__name__}: {e}")
        
        print("All authentication methods failed")
        return False

    def _try_certificate_auth(self, auth_url):
        """Try authentication with client certificate"""
        print("Attempting certificate authentication...")
        response = self.requests_pkcs12.post(
            auth_url,
            auth=(USERNAME, PASSWORD),
            data=self.body_form,
            pkcs12_filename=PFX_PATH,
            pkcs12_password=PFX_PASSPHRASE,
            verify=VERIFY_SSL,
            timeout=30,
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        return self._extract_token(response)

    def _try_basic_auth(self, auth_url):
        """Fallback to basic authentication without certificate"""
        print("Attempting basic authentication...")
        response = requests.post(
            auth_url,
            auth=(USERNAME, PASSWORD),
            data=self.body_form,
            verify=VERIFY_SSL,
            timeout=30,
            headers={"Content-Type": "application/x-www-form-urlencoded"}
        )
        return self._extract_token(response)

    def _try_token_auth(self, auth_url):
        """Alternative token-based authentication if applicable"""
        print("Attempting token authentication...")
        auth_data = {
            "username": USERNAME,
            "password": PASSWORD,
            **self.body_json
        }
        response = requests.post(
            auth_url,
            headers={"Content-Type": "application/json"},
            json=auth_data,
            verify=VERIFY_SSL,
            timeout=30
        )
        return self._extract_token(response)

    def _try_custom_auth(self, auth_url):
        """Fallback custom authentication method"""
        print("Attempting custom authentication...")
        response = self._make_request(
            "POST",
            auth_url,
            body=self.body_form,
            content_type="application/x-www-form-urlencoded"
        )
        return self._extract_token(response)

    def _extract_token(self, response):
        """Extract token from various response formats"""
        try:
            data = response.json()
            if 'access_token' in data:
                return data['access_token']
            elif 'token' in data:
                return data['token']
            elif 'authToken' in data:
                return data['authToken']
            else:
                print(f"Unexpected auth response format: {data}")
                return None
        except ValueError:
            print(f"Invalid JSON response: {response.text}")
            return None

    def generate_process_uids(self, count):
        """Generate multiple process UIDs using GET request"""
        uids = []
        for _ in range(count):
            try:
                response = self._make_request(
                    "GET",
                    URL_PROCESSING,
                    params=self.query_string
                )
                data = response.json()
                process_uid = data.get("processUid") or data.get("process_id") or data.get("id")
                if process_uid:
                    uids.append(process_uid)
                    print(f"Generated processUid: {process_uid}")
                else:
                    print(f"Unexpected response format, no processUid found: {data}")
            except Exception as e:
                print(f"Failed to generate processUid: {e}")
        
        return uids

    def check_status(self, process_uid):
        """Check status of a process with retries"""
        endpoint = URL_API.format(processUid=process_uid)
        
        for attempt in range(1, MAX_RETRIES + 1):
            try:
                start_time = time.time()
                response = self._make_request("GET", endpoint)
                elapsed = time.time() - start_time
                
                data = response.json()
                status = data.get("status", "Unknown")
                
                return {
                    "success": True,
                    "status": status,
                    "completed": status == "Completed",
                    "attempt": attempt,
                    "time": elapsed,
                    "data": data
                }
                
            except Exception as e:
                elapsed = time.time() - start_time if 'start_time' in locals() else 0
                print(f"Status check attempt {attempt} failed for {process_uid}: {e}")
                if attempt < MAX_RETRIES:
                    time.sleep(POLL_INTERVAL * attempt)  # Exponential backoff
        
        return {
            "success": False,
            "error": str(e),
            "time": elapsed,
            "attempt": attempt
        }

    def run_performance_test(self):
        """Run the complete performance test"""
        print("\n" + "="*50)
        print("Starting API Performance Test")
        print("="*50)
        
        test_start_time = time.time()
        
        # Authentication
        print("\n[1/4] Authenticating...")
        if not self.authenticate():
            print("Authentication failed. Cannot proceed with testing.")
            return None
        
        # Generate process UIDs
        print(f"\n[2/4] Generating {MAX_THREADS} process UIDs...")
        process_uids = self.generate_process_uids(MAX_THREADS)
        if not process_uids:
            print("Failed to generate any processUids. Cannot proceed with testing.")
            return None
        
        # Initialize results
        results = {
            "total_requests": 0,
            "successful_requests": 0,
            "failed_requests": 0,
            "completed_processes": 0,
            "incomplete_processes": 0,
            "response_times": [],
            "process_uids": process_uids,
            "test_start_time": test_start_time,
            "test_end_time": 0,
            "auth_time": self.auth_time,
            "detailed_results": []
        }
        
        print(f"\n[3/4] Running performance test for {TEST_DURATION} seconds...")
        print(f"Using {len(process_uids)} processUids with {MAX_THREADS} threads")
        
        def worker(process_uid):
            nonlocal results
            while time.time() - results["test_start_time"] < TEST_DURATION + results["auth_time"]:
                result = self.check_status(process_uid)
                results["total_requests"] += 1
                results["detailed_results"].append({
                    "process_uid": process_uid,
                    "timestamp": time.time(),
                    "result": result
                })
                
                if result["success"]:
                    results["successful_requests"] += 1
                    results["response_times"].append(result["time"])
                    
                    if result.get("completed", False):
                        results["completed_processes"] += 1
                    else:
                        results["incomplete_processes"] += 1
                else:
                    results["failed_requests"] += 1
                
                time.sleep(POLL_INTERVAL)
        
        # Run workers in thread pool
        with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
            futures = [executor.submit(worker, uid) for uid in process_uids]
            for future in futures:
                future.result()
        
        results["test_end_time"] = time.time()
        print("\n[4/4] Performance test completed")
        return results

    def analyze_results(self, results):
        """Analyze and summarize test results"""
        if not results:
            return None
        
        actual_duration = results["test_end_time"] - results["test_start_time"]
        requests_per_second = results["total_requests"] / actual_duration
        error_rate = (results["failed_requests"] / results["total_requests"]) * 100 if results["total_requests"] > 0 else 0
        completion_rate = (results["completed_processes"] / len(results["process_uids"])) * 100 if results["process_uids"] else 0
        
        if results["response_times"]:
            avg_response_time = statistics.mean(results["response_times"])
            min_response_time = min(results["response_times"])
            max_response_time = max(results["response_times"])
            percentile_95 = statistics.quantiles(results["response_times"], n=100)[-1]
        else:
            avg_response_time = min_response_time = max_response_time = percentile_95 = 0
        
        return {
            "test_configuration": {
                "auth_url": URL_AUTH,
                "processing_url": URL_PROCESSING,
                "api_url": URL_API,
                "test_duration_seconds": TEST_DURATION,
                "max_threads": MAX_THREADS,
                "poll_interval": POLL_INTERVAL,
                "max_retries": MAX_RETRIES,
                "query_parameters": QUERY_PARAMS,
                "post_body": POST_BODY
            },
            "authentication": {
                "auth_time_seconds": round(results["auth_time"], 3),
                "token_obtained": bool(self.token)
            },
            "processes": {
                "total_process_uids": len(results["process_uids"]),
                "completed_processes": results["completed_processes"],
                "incomplete_processes": results["incomplete_processes"],
                "completion_rate_percent": round(completion_rate, 2)
            },
            "requests": {
                "total_requests": results["total_requests"],
                "successful_requests": results["successful_requests"],
                "failed_requests": results["failed_requests"],
                "error_rate_percent": round(error_rate, 2),
                "requests_per_second": round(requests_per_second, 2)
            },
            "response_times": {
                "average_seconds": round(avg_response_time, 3),
                "minimum_seconds": round(min_response_time, 3),
                "maximum_seconds": round(max_response_time, 3),
                "95th_percentile_seconds": round(percentile_95, 3)
            },
            "test_duration_seconds": round(actual_duration, 2)
        }

    def save_results(self, results, analysis, filename="api_performance_test_results.json"):
        """Save test results to JSON file"""
        output = {
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "configuration": {
                "auth_url": URL_AUTH,
                "processing_url": URL_PROCESSING,
                "api_url": URL_API,
                "username": USERNAME,
                "test_duration": TEST_DURATION,
                "max_threads": MAX_THREADS,
                "query_params": QUERY_PARAMS,
                "post_body": POST_BODY
            },
            "summary": analysis,
            "raw_results": results
        }
        
        try:
            with open(filename, 'w') as f:
                json.dump(output, f, indent=2)
            print(f"\nResults saved to {filename}")
        except Exception as e:
            print(f"\nFailed to save results: {e}")

def main():
    tester = APITester()
    
    print("\nStarting API Performance Test")
    print("="*50)
    print(f"Authentication URL: {URL_AUTH} (POST)")
    print(f"Processing URL: {URL_PROCESSING} (GET)")
    print(f"API URL: {URL_API} (GET)")
    print(f"Test Duration: {TEST_DURATION} seconds")
    print(f"Max Threads: {MAX_THREADS}")
    print(f"Query Parameters: {QUERY_PARAMS}")
    print(f"POST Body: {POST_BODY}")
    print("="*50)
    
    test_results = tester.run_performance_test()
    
    if not test_results:
        print("\nPerformance test failed. Possible issues:")
        print("1. Authentication failed - check credentials and certificate")
        print("2. API endpoints are incorrect")
        print("3. Network connectivity issues")
        print("4. Server-side problems")
        return
    
    analysis = tester.analyze_results(test_results)
    
    print("\n=== Performance Test Summary ===")
    print(json.dumps(analysis, indent=2))
    
    print("\n=== Sample Detailed Results ===")
    for i, detail in enumerate(test_results["detailed_results"][:3]):
        print(f"\nSample {i+1} for processUid {detail['process_uid']}:")
        print(json.dumps(detail["result"], indent=2))
    
    tester.save_results(test_results, analysis)
    print("\nTest completed")

if __name__ == "__main__":
    main()
