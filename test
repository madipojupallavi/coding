import sys
import subprocess
import time
import statistics
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import parse_qsl
import json
import requests
import pandas as pd
from openpyxl import Workbook
from datetime import datetime
requests.packages.urllib3.disable_warnings()

# Configuration
URL_AUTH = "https:///token"
URL_PROCESSING = "https:///triggerMailBox"
URL_API = "https:///profiles/{processUid}"
USERNAME = ""
PASSWORD = ""
BODY = "t"
PFX_PATH = ""
PFX_PASSPHRASE = ""
VERIFY_SSL = True

# Test Configuration
TOTAL_PROCESSES = 50  # Exact number of processes to test
MAX_THREADS = 50      # Concurrent threads
TOKEN_REFRESH_TIME = 20  # seconds
OUTPUT_EXCEL = f"API_Test_Results_{datetime.now().strftime('%Y%m%d_%H%M%S')}.xlsx"

def ensure_requests_pkcs12():
    try:
        import requests_pkcs12
        return requests_pkcs12
    except ImportError:
        subprocess.check_call([sys.executable, "-m", "pip", "install", "requests_pkcs12"])
        import requests_pkcs12
        return requests_pkcs12

class TokenManager:
    """Handles token generation and refresh"""
    def __init__(self, requests_pkcs12):
        self.requests_pkcs12 = requests_pkcs12
        self.token = None
        self.token_timestamp = 0
        self.lock = threading.Lock()
    
    def get_token(self):
        with self.lock:
            current_time = time.time()
            if self.token is None or (current_time - self.token_timestamp) > TOKEN_REFRESH_TIME:
                self.token = self._fetch_new_token()
                self.token_timestamp = current_time
                print(f"New token generated at {datetime.fromtimestamp(current_time).strftime('%H:%M:%S')}")
            return self.token
    
    def _fetch_new_token(self):
        data = {"grant_type": "client_credentials"}
        try:
            response = self.requests_pkcs12.post(
                URL_AUTH,
                auth=(USERNAME, PASSWORD),
                data=data,
                headers={"Content-Type": "application/x-www-form-urlencoded"},
                pkcs12_filename=PFX_PATH,
                pkcs12_password=PFX_PASSPHRASE,
                verify=VERIFY_SSL,
                timeout=30
            )
            response.raise_for_status()
            return response.json().get("access_token")
        except Exception as e:
            print(f"Token generation failed: {str(e)}")
            return None

class TestRunner:
    def __init__(self):
        self.requests_pkcs12 = ensure_requests_pkcs12()
        self.token_manager = TokenManager(self.requests_pkcs12)
        self.results = []
        self.lock = threading.Lock()
        
    def generate_process_id(self, token):
        """Generate processUid (GET)"""
        headers = {"Authorization": f"Bearer {token}", "Accept": "application/json"}
        try:
            response = self.requests_pkcs12.get(
                URL_PROCESSING,
                headers=headers,
                pkcs12_filename=PFX_PATH,
                pkcs12_password=PFX_PASSPHRASE,
                verify=VERIFY_SSL,
                timeout=30
            )
            response.raise_for_status()
            process_id = response.json().get("processUid")
            print(f"Generated ProcessID: {process_id}")
            return process_id
        except Exception as e:
            print(f"ProcessID generation failed: {str(e)}")
            return None

    def check_api_status(self, token, process_id):
        """Check API status (GET)"""
        headers = {"Authorization": f"Bearer {token}", "Accept": "application/json"}
        try:
            start_time = time.time()
            response = self.requests_pkcs12.get(
                URL_API.format(processUid=process_id),
                headers=headers,
                pkcs12_filename=PFX_PATH,
                pkcs12_password=PFX_PASSPHRASE,
                verify=VERIFY_SSL,
                timeout=30
            )
            elapsed = time.time() - start_time
            status = f"{response.status_code} {response.reason}"
            return {
                "status": status,
                "response_time": elapsed,
                "success": response.status_code == 200
            }
        except Exception as e:
            return {
                "status": f"Error: {str(e)}",
                "response_time": 0,
                "success": False
            }

    def worker(self):
        """Single thread workflow"""
        token = self.token_manager.get_token()
        if not token:
            return None
            
        process_id = self.generate_process_id(token)
        if not process_id:
            return None
            
        result = self.check_api_status(token, process_id)
        
        with self.lock:
            self.results.append({
                "token_generation_time": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
                "process_id": process_id,
                "api_status": result["status"],
                "response_time_sec": result["response_time"],
                "success": result["success"]
            })
        
        print(f"Process {process_id}: {result['status']} ({result['response_time']:.2f}s)")
        return result

    def generate_report(self, test_duration):
        """Generate Excel report with detailed results"""
        df = pd.DataFrame(self.results)
        
        # Calculate metrics
        success_count = df['success'].sum()
        success_rate = (success_count / len(df)) * 100
        avg_response = df['response_time_sec'].mean()
        
        # Create Excel file with 2 sheets
        with pd.ExcelWriter(OUTPUT_EXCEL, engine='openpyxl') as writer:
            # Sheet 1: Detailed Results
            df.to_excel(
                writer, 
                sheet_name='Detailed Results', 
                index=False,
                columns=[
                    "token_generation_time",
                    "process_id", 
                    "api_status",
                    "response_time_sec",
                    "success"
                ]
            )
            
            # Sheet 2: Summary
            summary_data = {
                'Metric': [
                    'Total Processes',
                    'Successful',
                    'Failed',
                    'Success Rate',
                    'Average Response Time',
                    'Total Test Duration'
                ],
                'Value': [
                    TOTAL_PROCESSES,
                    success_count,
                    TOTAL_PROCESSES - success_count,
                    f"{success_rate:.2f}%",
                    f"{avg_response:.4f} sec",
                    f"{test_duration:.2f} sec"
                ]
            }
            pd.DataFrame(summary_data).to_excel(
                writer, 
                sheet_name='Summary', 
                index=False
            )
            
            # Auto-adjust column widths
            workbook = writer.book
            for sheetname in writer.sheets:
                sheet = workbook[sheetname]
                for column in sheet.columns:
                    max_length = max(
                        len(str(cell.value)) for cell in column
                    )
                    sheet.column_dimensions[
                        column[0].column_letter
                    ].width = max_length + 2

            # Add conditional formatting for failures
            sheet = workbook['Detailed Results']
            red_fill = PatternFill(start_color="FFC7CE", end_color="FFC7CE", fill_type="solid")
            for row in sheet.iter_rows(min_row=2, max_col=5, max_row=len(df)+1):
                if not row[4].value:  # 'Success' column
                    for cell in row:
                        cell.fill = red_fill

    def run_test(self):
        """Execute test with multithreading"""
        print(f"Starting test with {TOTAL_PROCESSES} processes using {MAX_THREADS} threads...")
        start_time = time.time()
        
        with ThreadPoolExecutor(max_workers=MAX_THREADS) as executor:
            futures = [executor.submit(self.worker) for _ in range(TOTAL_PROCESSES)]
            for future in as_completed(futures):
                future.result()  # Wait for completion
        
        test_duration = time.time() - start_time
        self.generate_report(test_duration)
        
        # Print final summary
        success_count = sum(1 for r in self.results if r.get('success', False))
        print(f"\nTest completed. Success: {success_count}/{TOTAL_PROCESSES}")
        print(f"Report generated: {OUTPUT_EXCEL}")
        return self.results

if __name__ == "__main__":
    test = TestRunner()
    results = test.run_test()
