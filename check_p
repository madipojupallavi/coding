def check_api_status(self, token, process_id):
    headers = {"Authorization": f"Bearer {token}", "Accept": "application/json"}
    try:
        start_time = time.time()
        response = self.requests_pkcs12.get(
            URL_API.format(processUid=process_id),
            headers=headers,
            pkcs12_filename=PFX_PATH,
            pkcs12_password=PFX_PASSPHRASE,
            verify=VERIFY_SSL,
            timeout=30
        )
        elapsed = time.time() - start_time
        
        # Calculate request/response sizes
        request_size = len(str(headers)) + len(URL_API.format(processUid=process_id))
        response_size = len(response.text)
        
        # First check if response is 200 OK
        if response.status_code != 200:
            with self.lock:
                self.api_stats.append({
                    "process_id": process_id,
                    "response_time": elapsed,
                    "request_size_bytes": request_size,
                    "response_size_bytes": response_size,
                    "success": False,
                    "error": f"{response.status_code} {response.reason}",
                    "final_status": "HTTP Error"
                })
            return {
                "status": f"{response.status_code} {response.reason}",
                "response_time": elapsed,
                "success": False,
                "final_status": "HTTP Error",
                "request_size_bytes": request_size,
                "response_size_bytes": response_size
            }
        
        # If 200 OK, check the JSON response for status in content
        try:
            response_json = response.json()
            content_status = response_json.get("content", {}).get("status", "Unknown")
            
            # If status is not Completed, poll until it is or max attempts reached
            if content_status != "Completed":
                attempts = 1
                while attempts < MAX_STATUS_CHECKS and content_status != "Completed":
                    time.sleep(STATUS_CHECK_INTERVAL)
                    check_start = time.time()
                    response = self.requests_pkcs12.get(
                        URL_API.format(processUid=process_id),
                        headers=headers,
                        pkcs12_filename=PFX_PATH,
                        pkcs12_password=PFX_PASSPHRASE,
                        verify=VERIFY_SSL,
                        timeout=30
                    )
                    check_elapsed = time.time() - check_start
                    elapsed += check_elapsed  # Accumulate all check times
                    
                    # Accumulate request/response sizes
                    request_size += len(str(headers)) + len(URL_API.format(processUid=process_id))
                    response_size += len(response.text)
                    
                    if response.status_code != 200:
                        with self.lock:
                            self.api_stats.append({
                                "process_id": process_id,
                                "response_time": elapsed,
                                "request_size_bytes": request_size,
                                "response_size_bytes": response_size,
                                "success": False,
                                "error": f"Status check failed: {response.status_code} {response.reason}",
                                "final_status": "HTTP Error during polling"
                            })
                        return {
                            "status": f"Status check failed: {response.status_code} {response.reason}",
                            "response_time": elapsed,
                            "success": False,
                            "final_status": "HTTP Error during polling",
                            "request_size_bytes": request_size,
                            "response_size_bytes": response_size
                        }
                    
                    response_json = response.json()
                    content_status = response_json.get("content", {}).get("status", "Unknown")
                    attempts += 1
            
            if content_status == "Completed":
                with self.lock:
                    self.api_stats.append({
                        "process_id": process_id,
                        "response_time": elapsed,
                        "request_size_bytes": request_size,
                        "response_size_bytes": response_size,
                        "success": True,
                        "final_status": "Completed"
                    })
                return {
                    "status": f"200 OK - Completed",
                    "response_time": elapsed,
                    "success": True,
                    "final_status": "Completed",
                    "request_size_bytes": request_size,
                    "response_size_bytes": response_size
                }
            else:
                with self.lock:
                    self.api_stats.append({
                        "process_id": process_id,
                        "response_time": elapsed,
                        "request_size_bytes": request_size,
                        "response_size_bytes": response_size,
                        "success": False,
                        "error": f"Final status: {content_status} (after {attempts} checks)",
                        "final_status": f"Timeout - {content_status}"
                    })
                return {
                    "status": f"200 OK - Final status: {content_status} (after {attempts} checks)",
                    "response_time": elapsed,
                    "success": False,
                    "final_status": f"Timeout - {content_status}",
                    "request_size_bytes": request_size,
                    "response_size_bytes": response_size
                }
                
        except ValueError:  # JSON decode error
            with self.lock:
                self.api_stats.append({
                    "process_id": process_id,
                    "response_time": elapsed,
                    "request_size_bytes": request_size,
                    "response_size_bytes": response_size,
                    "success": False,
                    "error": "Invalid JSON response",
                    "final_status": "Invalid JSON"
                })
            return {
                "status": "200 OK - Invalid JSON response",
                "response_time": elapsed,
                "success": False,
                "final_status": "Invalid JSON",
                "request_size_bytes": request_size,
                "response_size_bytes": response_size
            }
            
    except Exception as e:
        with self.lock:
            self.api_stats.append({
                "process_id": process_id,
                "response_time": 0,
                "request_size_bytes": 0,
                "response_size_bytes": 0,
                "success": False,
                "error": str(e),
                "final_status": f"Exception: {str(e)}"
            })
        return {
            "status": f"Error: {str(e)}",
            "response_time": 0,
            "success": False,
            "final_status": f"Exception: {str(e)}",
            "request_size_bytes": 0,
            "response_size_bytes": 0
        }
